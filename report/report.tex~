\documentclass{article}
\usepackage{blindtext}
\usepackage{authblk}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{amssymb}
\usepackage[overload]{empheq}
\newcommand{\for}{\text{for }}
 
\title{SPM project: Parallel Prefix}
\author{Gaspare Ferraro, 520549}
\affil{Master Degree in Computer Science - University of Pisa}
\affil[]{ferraro@gaspa.re}
\date{\today}
 
\begin{document}
 
\maketitle
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

In this report we will analyze, theoretically and practically, the resolution of the problem of the (parallel) prefix sum:

\medskip

\textit{Given a vector $x = \langle x_{0}, x_{1}, \ldots, x_{n-1} \rangle$ and a binary operation $\oplus$ compute the vector $y = \langle x_{0}, x_{0} \oplus x_{1}, x_{0} \oplus x_{1} \oplus x_{2}, \ldots, x_{0} \oplus x_{1} \oplus \ldots \oplus x_{n-1} \rangle$.} % , i.e. each element of the output vector at position $i$ is the results of 

\medskip

For the analysis of the problem we have to make two assumptions:

\begin{itemize}
  \item The binary operation $\oplus$ is associative ($ a \oplus ( b \oplus c ) =  (a \oplus b) \oplus c  $) and commutative ($a \oplus b = b \oplus a$), this is an important assumption as we will see in the next chapters the order of the operations may not be preserved.
  \item The size of the input vector is a power of $2$, not a strong assumption, as all the algorithms we will present could be easily generalize to all the sizes, but it only helps to simplify some operations.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sequential algorithm}

The sequential algorithm simple compute each element of the vector $y$ as follow:

\begin{equation*}[]
    y_{i} =
    \begin{cases}
      x_{0}& \for i = 0 \\
      x_{i} \oplus y_{i-1},& \for 0 <  i < n
    \end{cases}
\end{equation*}

This algorithm is optimal in a sequential model as it has a running time of $\mathcal{O}(n)$, assuming that $\oplus$ is $\mathcal{O}(1)$, and performs $n-1$ calls to $\oplus$ operation.
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parallel architecture design}

The problem of computing the prefix sum vector is a classical example of a problem that have an optimal solution in a sequential model but that can be optimized in a parallel model. 
The optimization is not in terms of total complexity or in the number of $\oplus$ operations performed (which are already optimals in the sequential algorithm) but in terms of completion time. When 
\medskip

We will now introduce two different algorithms that solve in an efficient way the prefix sum problem in a parallel model. 

\subsection{Block-based algorithm}

The idea behind the first algorithm is to split the input vector in blocks of same size, compute the prefix vector of each block and then.


For example: 


\begin{equation*}
  x^{1} = \langle x_0, x_1, \ldots, x_{n/2-1} \rangle \rightarrow y^{1} = \langle x_0, x_0 \oplus x_1, \ldots, x_0 \oplus x_1 \oplus \ldots \oplus x_{n/2-1} \rangle 
\end{equation*}
\begin{equation*}
  x^{2} = \langle x_{n/2}, x_{n/2+1}, \ldots, x_{n-1} \rangle \rightarrow y^{1} = \langle x_{n/2}, x_{n/2} \oplus x_{n/2+1} \ldots, x_0 \oplus x_1 \oplus \ldots \oplus x_{n/2} \rangle 
\end{equation*}

\subsection{Circuit-based algorithm}

Another kind of algorithms are the one based on a circuit-like rappresentation, 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Performance modeling}

 
\subsection{Block-based algorithm}


\subsection{Circuit-based algorithm}

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementations structure and details}

All the implementations are written in $C++17$, the source code is available as attachment with the report or on GitHub (https://github.com/GaspareG/ParallelPrefix).


\subsection{Sequential algorithm}

The sequential implementations 

\subsection{Block-based algorithm}

TODO

\subsection{Circuit-based algorithm}

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experimental validation}


\subsection{experiments details}

\subsection{benchmark results}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
